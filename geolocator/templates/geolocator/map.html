<!DOCTYPE html>
<html>
  <head>
    <title>Atlanta Food Finder</title>
      
    {% load static %}  
    <link rel="stylesheet" type="text/css" href="{% static 'geolocator/css/map.css' %}">
  </head>
  <body>
    <h3>Atlanta Food Finder</h3>

    <!-- Search bar -->
    <div id="search-container">
      <input id="search-input" type="text" placeholder="Search for restaurants..." />
    </div>

    <!-- The container for the map -->
    <div id="map"></div>

    <!-- Results Tab and Filters for distance and rating -->
    <div id="results-container" style="display:none;">
      <h4>Search Results</h4>

      <label for="distance">Max Distance (meters):</label>
      <input id="distance" type="number" value="5000" min="0">

      <label for="rating">Minimum Rating:</label>
      <input id="rating" type="number" value="4" step="0.1" min="0" max="5">

      <button id="apply-filters">Apply Filters</button>

      <ul id="results-list"></ul>  <!-- Unordered list to hold the place results -->
    </div>

    <!-- Load the Google Maps API with the Places library -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key={{ google_api_key }}&libraries=places"
      async
      defer
    ></script>

    <script>
      let map;
      let service;
      let infowindow;
      let markers = [];
      let placesResults = [];

      function initMap() {
        const defaultLocation = { lat: 33.7490, lng: -84.3880 }; // Atlanta, GA

        // Initialize the map
        map = new google.maps.Map(document.getElementById("map"), {
          center: defaultLocation,
          zoom: 12,
        });

        infowindow = new google.maps.InfoWindow();

        // Initialize the search box
        const input = document.getElementById("search-input");
        const searchBox = new google.maps.places.SearchBox(input);

        // Bias the search results towards the current map's viewport
        map.addListener("bounds_changed", () => {
          searchBox.setBounds(map.getBounds());
        });

        // Listen for the search box input
        searchBox.addListener("places_changed", () => {
          const places = searchBox.getPlaces();

          if (places.length == 0) {
            return;
          }

          // Show results container and clear any previous results
          document.getElementById('results-container').style.display = 'block';
          clearMarkers();
          placesResults = places;

          // Create markers for all the search results and populate the list
          updateResultsList(placesResults);
          places.forEach((place) => {
            if (!place.geometry || !place.geometry.location) {
              console.log("Returned place contains no geometry");
              return;
            }
            createMarker(place);
          });

          // Adjust the map's viewport to fit the results
          const bounds = new google.maps.LatLngBounds();
          places.forEach((place) => {
            if (place.geometry.viewport) {
              bounds.union(place.geometry.viewport);
            } else {
              bounds.extend(place.geometry.location);
            }
          });
          map.fitBounds(bounds);
        });

        // Apply filters when the user clicks the "Apply Filters" button
        document.getElementById('apply-filters').addEventListener('click', function () {
          const maxDistance = parseFloat(document.getElementById('distance').value);
          const minRating = parseFloat(document.getElementById('rating').value);
          filterResults(maxDistance, minRating);
        });
      }

      // Function to update the results list in the sidebar
      function updateResultsList(places) {
        const resultsList = document.getElementById('results-list');
        resultsList.innerHTML = '';

        places.forEach((place) => {
          const li = document.createElement('li');
          li.textContent = `${place.name} (Rating: ${place.rating || 'N/A'})`;
          
          // Center the map on the place when clicked
          li.addEventListener('click', function() {
            map.setCenter(place.geometry.location);
            infowindow.setContent(`${place.name}<br>Rating: ${place.rating || 'N/A'}`);
            infowindow.open(map);
          });
          
          resultsList.appendChild(li);
        });
      }

      // Function to filter the places based on distance and rating
      function filterResults(maxDistance, minRating) {
        const center = map.getCenter();
        const filteredResults = placesResults.filter((place) => {
          const meetsRating = place.rating >= minRating;
          const distance = google.maps.geometry.spherical.computeDistanceBetween(
            center, place.geometry.location
          );
          const meetsDistance = distance <= maxDistance;

          return meetsRating && meetsDistance;
        });

        // Update markers and the results list based on filters
        clearMarkers();
        updateResultsList(filteredResults);

        filteredResults.forEach((place) => {
          createMarker(place);
        });
      }

      // Function to create a marker on the map for a given place
      function createMarker(place) {
        const marker = new google.maps.Marker({
          map: map,
          position: place.geometry.location,
          title: place.name,
        });

        markers.push(marker);

        google.maps.event.addListener(marker, 'click', function () {
          infowindow.setContent(`${place.name}<br>Rating: ${place.rating || 'N/A'}`);
          infowindow.open(map, this);
        });
      }

      // Function to clear all markers from the map
      function clearMarkers() {
        markers.forEach((marker) => marker.setMap(null));
        markers = [];
      }

      window.onload = initMap;
    </script>
  </body>
</html>
